#lang racket
(require
 ;"sicp-lang.rkt"
 "3.5.1_stream.rkt"
 "3.5.2_infinite-stream.rkt")

;; utils
(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1)
                                  high))))


;; use stream to express the newton's
;; method to computer sqrt
(define (average x y) (/ (+ x y) 2))
(define (square x) (* x x))

(define (sqrt-improve guess x)
  (average guess (/ x guess)))

(define (sqrt-stream x)
  (define guesses
    (cons-stream 1.0
                 (stream-map (lambda (guess)
                               (sqrt-improve guess x))
                             guesses)))
  guesses)


;; a series to compute PI
(define (pi-summands n)
  (cons-stream (/ 1.0 n)
               (neg-stream (pi-summands (+ n 2)))))

(define pi-stream
  (scale-stream (partial-sums (pi-summands 1)) 4))

;; (display-partial-stream pi-stream 10)


;; Euler's transform to accelerate the convergence
;; of alternating series
(define (euler-transform s)
  (let ([s0 (stream-ref s 0)]
        [s1 (stream-ref s 1)]
        [s2 (stream-ref s 2)])
    (cons-stream
     (- s2 (/ (square (- s2 s1))
              (+ s0 (* -2 s1) s2)))
     (euler-transform (stream-cdr s)))))

;; (define acc-pi-stream (euler-transform pi-stream))
;; (display-partial-stream acc-pi-stream 10)

;; euler-transform can be applied iteratively
;; to accelerate even further
(define (make-tableau transform s)
  (cons-stream s
        (make-tableau transform
                      (transform s))))

(define (accelerated-sequence transform s)
  (stream-map stream-car
              (make-tableau transform s)))

;; (define supacc-pi-stream
;;   (accelerated-sequence euler-transform pi-stream))
;; (display-partial-stream supacc-pi-stream 10)


;; Ex 3.64
(define (stream-limit s tolerance)
  (let ([s0 (stream-ref s 0)]
        [s1 (stream-ref s 1)])
    (if (< (abs (- s0 s1)) tolerance)
        s1
        (stream-limit (stream-cdr s) tolerance))))
; test
(define (sqrt x tolerance)
  (stream-limit (sqrt-stream x) tolerance))
;; (sqrt 2 0.00001)


;; Ex 3.65
(define (ln2-summands n)
  (cons-stream (/ 1.0 n)
               (neg-stream (ln2-summands (+ n 1)))))

(define ln2-stream (partial-sums (ln2-summands 1)))
;; (display-partial-stream ln2-stream 8)

;; accelerated streams
;; (newline)
;; (display-partial-stream (euler-transform ln2-stream) 8)
;; (newline)
;; (display-partial-stream (accelerated-sequence euler-transform ln2-stream) 8)



;; infinite streams of pairs
(define (append-streams s1 s2)
  (cond [(stream-null? s1) s2]
        [(stream-null? s2) s1]
        [else (cons-stream (stream-car s1)
                           (append-streams
                            (stream-cdr s1) s2))]))
;test
(define s1 (stream-enumerate-interval 0 5))
(define s2 (stream-enumerate-interval 1 3))
;(define s3 (append-streams s1 pos-integers))

(define (stream-flatmap p s)
  ;;(displayln (stream-car s))
  (if (> (stream-car s) 100) (exit) 0)
  (let ([mapped (stream-map p s)])
    (if (stream-null? s)
        the-empty-stream
        (append-streams
         (p (stream-car s))
         (stream-flatmap
          p (stream-cdr s))))))

(define int-pairs  ;; a stream of int-pairs (i, j) with i <= j
  (stream-flatmap
   (lambda (j)
     (stream-map
      (lambda (i)
        (list i j))
      (stream-enumerate-interval 1 j)))
   pos-integers))
(define prime-sum-pairs
  (stream-filter (lambda (p)
                   (prime? (+ (car p) (cadr p))))
                 int-pairs))

