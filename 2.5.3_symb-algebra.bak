#lang racket
(require (except-in "data-structures.rkt" apply-generic)
         "2.5.2__type-tower__.rkt")

(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable coeff-list)
    (define (coeffL->termL cL)
      (if (null? cL)
          null
          (cons (make-term (sub1 (length cL))
                           (car cL))
                (coeffL->termL (cdr cL)))))
    (cons variable (coeffL->termL coeff-list)))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  (define (same-variable? x y)
    (and (symbol? x)
         (symbol? y)
         (eq? x y)))

  ;; representation of terms and term lists
  (define the-empty-termlist null)
  (define (empty-termlist? tl) (null? tl))
  (define (make-term order coeff) (cons order coeff))
  (define (order term) (car term))
  (define (coeff term) (cdr term))
  (define (first-term tl) (car tl))
  (define (rest-terms tl) (cdr tl))
  (define (adjoin-term term tl) (cons term tl))

  (define (add-poly p1 p2)
    (if (same-variable? (variable p1)
                        (variable p2))
        (make-poly
         (variable p1)
         (add-terms (term-list p1)
                    (term-list p2)))
        (error "Polys not in same var:
              ADD-POLY"
               (list p1 p2))))

  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1)
                        (variable p2))
        (make-poly
         (variable p1)
         (mul-terms (term-list p1)
                    (term-list p2)))
        (error "Polys not in same var:
              MUL-POLY"
               (list p1 p2))))

  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term
                     t1
                     (add-terms (rest-terms L1)
                                L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term
                     t2
                     (add-terms
                      L1
                      (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term
                      (order t1)
                      (add (coeff t1)
                           (coeff t2)))
                     (add-terms
                      (rest-terms L1)
                      (rest-terms L2)))))))))

  (define (mul-terms L1 L2)
    (define (mul-term-by-all-terms t1 L)
      (if (empty-termlist? L)
          (the-empty-termlist)
          (let ((t2 (first-term L)))
            (adjoin-term
             (make-term
              (+ (order t1) (order t2))
              (mul (coeff t1) (coeff t2)))
             (mul-term-by-all-terms
              t1
              (rest-terms L))))))
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms
         (mul-term-by-all-terms
          (first-term L1) L2)
         (mul-terms (rest-terms L1) L2))))

  (define (print-poly poly)
    (define (print-term term var)
      (let ([ord (order term)]
            [cf (coeff term)])
        (print cf)
        (display var)
        (display "^")
        (display ord)))
    (define (print-terms terms var)
      (cond ((null? terms) (display ""))
            ((null? (cdr terms)) (print-term (car terms) var))
            (else (print-term (car terms var))
                  (display " + ")
                  (print-terms (cdr terms)))))
    (print-terms (term-list poly) (variable poly)))

  ;; interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2)
         (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2)
         (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms)
         (tag (make-poly var terms))))
  (put 'print '(polynomial) print-poly)
  'done)

(define (make-poly var term-list)
  ((get 'make 'polynomial) var term-list))

(define (add-poly-package)
  (type-conversion-update)
  (install-polynomial-package))

(add-poly-package)
(define p (make-poly 'x '[1 2 3]))
(define q (make-poly 'x '[2 3 4 5]))
