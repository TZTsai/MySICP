#lang sicp

;;;My goal in this file is to implement a symbolic differentiation system that returns a polynomial of the given
;;;variable in ascending powers which is the derivative of the given expression



(define (make-sum a1 a2)
  (cond ((=number? a2 0) a1)
        ((=number? a1 0) a2)
        ((and (number? a1) (number? a2))
         (+ a1 a2))
        ((same-variable? a1 a2) (make-product 2 a1))
        ((> (order a1) (order a2)) (make-sum a2 a1))
        ((sum? a1) (make-sum (addend a1)
                             (make-sum (augend a1) a2)))
        ((= (order a1) (order a2))
         (display 90) (newline)
         (cond ((and (exponentiation? a1) (exponentiation? a2))
                (make-product 2 a1))
               ((and (exponentiation? a1)
                     (product? a2))
                (make-product (make-sum (multiplier a2) 1) a1))
               ((and (product? a1) (product? a2))
                (make-product (make-sum (multiplier a1)(multiplier a2))
                              (multiplicand a1)))
               ((and (variable? a1) (product? a2))
                (make-product (make-sum 1 (multiplier a2))
                              (multiplicand a2)))
               (else (make-sum a2 a1))))                              
        ;(else (list '+ a1 a2))))
        (else (list a1 '+ a2))))

(define (make-product p1 p2)
  (cond ((or (=number? p1 0)
             (=number? p2 0))
         0)
        ((=number? p1 1) p2)
        ((=number? p2 1) p1)
        ((and (number? p1) (number? p2))
         (* p1 p2))
        ((number? p2) (make-product p2 p1))
        ((same-variable? p1 p2) (make-exponentiation p1 2))
        ((sum? p1) (make-sum (make-product (addend p1) p2)
                             (make-product (augend p1) p2)))
        ((sum? p2) (make-sum (make-product p1 (addend p2))
                             (make-product p1 (augend p2))))
        ((power-of? p1 p2) (make-exponentiation p1 (make-sum 1 (exponent p2))))
        ((power-of? p2 p1) (make-exponentiation p2 (make-sum 1 (exponent p1))))
        ((and (exponentiation? p1) (power-of? (base p1) p2))
         (make-exponentiation (base p1) (+ (exponent p1) (exponent p2))))
        ((product? p1) (display 137) (newline) (display p1) (display " *** ") (display p2)
                       (let ((m1 (multiplier p1)) (m2 (multiplicand p1)))
                         (if (and (number? p2) (number? m1))
                             (make-product (* p2 m1) m2)
                             (make-product m2 (make-product m1 p2)))))
        ((product? p2) (display 143) (make-product p2 p1))
        ;(else (list '* p1 p2))))
        (else (list p1 '* p2))))

(define (make-exponentiation b e)
  (cond ((=number? e 0) 1)
        ((=number? e 1) b)
        ((=number? b 0) 0)
        ((=number? b 1) 1)
        ((and (number? b) (number? e)) (expt b e))
        ((sum? b) (make-product b (make-exponentiation b (- e 1))))
        ;(else (list '^ b e))))
        (else (list b '^ e))))


(define (power-of? var exp)
  (and (exponentiation? exp)
       (same-variable? (base exp) var)))

(define (order exp)
  (cond ((constant? exp) 0)
        ((variable? exp) 1)
        ((sum? exp) (max (order (addend exp))
                         (order (augend exp))))
        ((product? exp) (+ (order (multiplier exp))
                           (order (multiplicand exp))))
        ((exponentiation? exp) (exponent exp))
        (else 0)))
